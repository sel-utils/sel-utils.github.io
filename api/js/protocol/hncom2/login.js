/*
 * This file was automatically generated by sel-utils and
 * released under the MIT License.
 * 
 * License: https://github.com/sel-project/sel-utils/blob/master/LICENSE
 * Repository: https://github.com/sel-project/sel-utils
 * Generated from https://github.com/sel-project/sel-utils/blob/master/xml/protocol/hncom2.xml
 */
/** @module sul/protocol/hncom2/login */

//import Types from 'types';

/**
 * Packets used during the authentication process to exchange informations.
 */
const Login = {

	/**
	 * First real packet sent by the client with its informations.
	 */
	ConnectionRequest: class extends Buffer {

		static get ID(){ return 3; }

		static get CLIENTBOUND(){ return false; }
		static get SERVERBOUND(){ return true; }

		/**
		 * @param protocol
		 *        Version of the protocol used by the client that must match the hub's one.
		 * @param password
		 *        Password, if the hub requires one, or an empty string.
		 * @param name
		 *        Name of the node that will be validated by the hub. It should always be lowercase and only contain
		 *        letters, numbers, dashes and underscores.
		 * @param main
		 *        Indicates whether the node accepts clients when they first connect to the hub or exclusively when
		 *        they are manually transferred.
		 */
		constructor(protocol=0, password="", name="", main=true) {
			super();
			this.protocol = protocol;
			this.password = password;
			this.name = name;
			this.main = main;
		}

		/** @return {Uint8Array} */
		encode() {
			this._buffer = [];
			this.writeBigEndianByte(3);
			this.writeVaruint(this.protocol);
			var dhc5ynd9=this.encodeString(this.password); this.writeVaruint(dhc5ynd9.length); this.writeBytes(dhc5ynd9);
			var dhc5y1=this.encodeString(this.name); this.writeVaruint(dhc5y1.length); this.writeBytes(dhc5y1);
			this.writeBigEndianByte(this.main?1:0);
			return new Uint8Array(this._buffer);
		}

		/** @param {(Uint8Array|Array)} buffer */
		decode(_buffer) {
			this._buffer = Array.from(_buffer);
			var _id=this.readBigEndianByte();
			this.protocol=this.readVaruint();
			this.password=this.decodeString(this.readBytes(this.readVaruint()));
			this.name=this.decodeString(this.readBytes(this.readVaruint()));
			this.main=this.readBigEndianByte()!==0;
			return this;
		}

		/** @param {(Uint8Array|Array)} buffer */
		static fromBuffer(buffer) {
			return new Login.ConnectionRequest().decode(buffer);
		}

		/** @return {string} */
		toString() {
			return "ConnectionRequest(protocol: " + this.protocol + ", password: " + this.password + ", name: " + this.name + ", main: " + this.main + ")";
		}

	},

	/**
	 * Reply sent after the ConnectionRequest packet if the node's ip has been accepted.
	 * It indicates the status of the connection.
	 */
	ConnectionResponse: class extends Buffer {

		static get ID(){ return 4; }

		static get CLIENTBOUND(){ return true; }
		static get SERVERBOUND(){ return false; }

		// status
		static get OK(){ return 0; }
		static get OUTDATED_HUB(){ return 1; }
		static get OUTDATED_NODE(){ return 2; }
		static get PASSWORD_REQUIRED(){ return 3; }
		static get WRONG_PASSWORD(){ return 4; }
		static get INVALID_NAME_LENGTH(){ return 5; }
		static get INVALID_NAME_CHARACTERS(){ return 6; }
		static get NAME_ALREADY_USED(){ return 7; }
		static get NAME_RESERVED(){ return 8; }

		/**
		 * @param status
		 *        Indicates the status of connection. If not 0, it indicates an error.
		 * @param protocol
		 *        Indicates the version of the protocol used by the hub when the status code indicates that the hub
		 *        or the node is obsolete.
		 */
		constructor(status=0, protocol=0) {
			super();
			this.status = status;
			this.protocol = protocol;
		}

		/** @return {Uint8Array} */
		encode() {
			this._buffer = [];
			this.writeBigEndianByte(4);
			this.writeBigEndianByte(this.status);
			if(status==1||status==2){ this.writeVaruint(this.protocol); }
			return new Uint8Array(this._buffer);
		}

		/** @param {(Uint8Array|Array)} buffer */
		decode(_buffer) {
			this._buffer = Array.from(_buffer);
			var _id=this.readBigEndianByte();
			this.status=this.readBigEndianByte();
			if(status==1||status==2){ this.protocol=this.readVaruint(); }
			return this;
		}

		/** @param {(Uint8Array|Array)} buffer */
		static fromBuffer(buffer) {
			return new Login.ConnectionResponse().decode(buffer);
		}

		/** @return {string} */
		toString() {
			return "ConnectionResponse(status: " + this.status + ", protocol: " + this.protocol + ")";
		}

	},

	/**
	 * Informations about the hub.
	 */
	HubInfo: class extends Buffer {

		static get ID(){ return 5; }

		static get CLIENTBOUND(){ return true; }
		static get SERVERBOUND(){ return false; }

		// max
		static get UNLIMITED(){ return -1; }

		/**
		 * @param time
		 *        Unix time with microseconds precision that indicates the exact moment when this packet was created.
		 *        It's used by the node to calculate the latency.
		 * @param serverId
		 *        Server's id, either given by a snoop system or randomly generated at runtime.
		 * @param reservedUuids
		 *        First number of the 4,294,967,296 (2³²) reserved by the hub to create the node's UUIDs. Every
		 *        UUID generated by the node is formed by the server's id (most signicant) and the next reserved uuid
		 *        (least significant). This way every UUID in the hub and in the connected nodes is always different.
		 * @param displayName
		 *        Unformatted name of the server as indicated in the hub's configuration file.
		 * @param gamesInfo
		 *        Informations about the games supported by the hub.
		 * @param online
		 *        Number of players currently online and connected to other nodes.
		 * @param max
		 *        Number of maximum players that can connect to the server (that is the sum of the max players of the
		 *        nodes already connected). The number may change after this node connects.
		 * @param language
		 *        Default server's language in format (language_COUNTRY, e.g. en_GB) and also the default language
		 *        for players that don't specify their language or for the ones which language is not supported by
		 *        the server.
		 * @param acceptedLanguages
		 *        Languages accepted by the server in the same format as {language}. The list should always contain
		 *        at least one element (the default language).
		 * @param additionalJson
		 *        Optional informations about the server's software, social accounts, system and options in the
		 *        format indicated below.
		 */
		constructor(time=0, serverId=0, reservedUuids=0, displayName="", gamesInfo=[], online=0, max=0, language="", acceptedLanguages=[], additionalJson="") {
			super();
			this.time = time;
			this.serverId = serverId;
			this.reservedUuids = reservedUuids;
			this.displayName = displayName;
			this.gamesInfo = gamesInfo;
			this.online = online;
			this.max = max;
			this.language = language;
			this.acceptedLanguages = acceptedLanguages;
			this.additionalJson = additionalJson;
		}

		/** @return {Uint8Array} */
		encode() {
			this._buffer = [];
			this.writeBigEndianByte(5);
			this.writeVarulong(this.time);
			this.writeVarulong(this.serverId);
			this.writeVarulong(this.reservedUuids);
			var dhc5anbf=this.encodeString(this.displayName); this.writeVaruint(dhc5anbf.length); this.writeBytes(dhc5anbf);
			this.writeVaruint(this.gamesInfo.length); for(var dhc5y1cl in this.gamesInfo){ this.writeBytes(this.gamesInfo[dhc5y1cl].encode()); }
			this.writeVaruint(this.online);
			this.writeVarint(this.max);
			var dhc5y5df=this.encodeString(this.language); this.writeVaruint(dhc5y5df.length); this.writeBytes(dhc5y5df);
			this.writeVaruint(this.acceptedLanguages.length); for(var dhc5yncr in this.acceptedLanguages){ var dhc5yncr=this.encodeString(this.acceptedLanguages[dhc5yncr]); this.writeVaruint(dhc5yncr.length); this.writeBytes(dhc5yncr); }
			var dhc5zrdl=this.encodeString(this.additionalJson); this.writeVaruint(dhc5zrdl.length); this.writeBytes(dhc5zrdl);
			return new Uint8Array(this._buffer);
		}

		/** @param {(Uint8Array|Array)} buffer */
		decode(_buffer) {
			this._buffer = Array.from(_buffer);
			var _id=this.readBigEndianByte();
			this.time=this.readVarulong();
			this.serverId=this.readVarulong();
			this.reservedUuids=this.readVarulong();
			this.displayName=this.decodeString(this.readBytes(this.readVaruint()));
			var aramzfzn=this.readVaruint(); this.gamesInfo=[]; for(var dhc5y1cl=0;dhc5y1cl<aramzfzn;dhc5y1cl++){ this.gamesInfo[dhc5y1cl]=Types.GameInfo.fromBuffer(this._buffer); this._buffer=this.gamesInfo[dhc5y1cl]._buffer; }
			this.online=this.readVaruint();
			this.max=this.readVarint();
			this.language=this.decodeString(this.readBytes(this.readVaruint()));
			var aramynzb=this.readVaruint(); this.acceptedLanguages=[]; for(var dhc5yncr=0;dhc5yncr<aramynzb;dhc5yncr++){ this.acceptedLanguages[dhc5yncr]=this.decodeString(this.readBytes(this.readVaruint())); }
			this.additionalJson=this.decodeString(this.readBytes(this.readVaruint()));
			return this;
		}

		/** @param {(Uint8Array|Array)} buffer */
		static fromBuffer(buffer) {
			return new Login.HubInfo().decode(buffer);
		}

		/** @return {string} */
		toString() {
			return "HubInfo(time: " + this.time + ", serverId: " + this.serverId + ", reservedUuids: " + this.reservedUuids + ", displayName: " + this.displayName + ", gamesInfo: " + this.gamesInfo + ", online: " + this.online + ", max: " + this.max + ", language: " + this.language + ", acceptedLanguages: " + this.acceptedLanguages + ", additionalJson: " + this.additionalJson + ")";
		}

	},

	/**
	 * Informations about the node.
	 */
	NodeInfo: class extends Buffer {

		static get ID(){ return 6; }

		static get CLIENTBOUND(){ return false; }
		static get SERVERBOUND(){ return true; }

		// max
		static get UNLIMITED(){ return 0; }

		/**
		 * @param time
		 *        Unix time with microseconds precision that indicates the exact moment when this packet was created.
		 *        It's used by the hub to calculate the latency.
		 * @param max
		 *        Maximum number of players accepted by node.
		 * @param acceptedGames
		 *        Informations about the games accepted by the node. There should be at least one combination of game/protocol
		 *        that is also accepted by hub as indicated in {HubInfo.gamesInfo}, otherwise the node will never
		 *        receive any player.
		 * @param plugins
		 *        List of plugins loaded on the node for creating queries on the hub.
		 * @param additionalJson
		 *        Optional informations about the server's software and system, similar to {HubInfo.additionalJson}.
		 */
		constructor(time=0, max=0, acceptedGames=[], plugins=[], additionalJson="") {
			super();
			this.time = time;
			this.max = max;
			this.acceptedGames = acceptedGames;
			this.plugins = plugins;
			this.additionalJson = additionalJson;
		}

		/** @return {Uint8Array} */
		encode() {
			this._buffer = [];
			this.writeBigEndianByte(6);
			this.writeVarulong(this.time);
			this.writeVaruint(this.max);
			this.writeVaruint(this.acceptedGames.length); for(var dhc5yncr in this.acceptedGames){ this.writeBytes(this.acceptedGames[dhc5yncr].encode()); }
			this.writeVaruint(this.plugins.length); for(var dhc5bva5 in this.plugins){ this.writeBytes(this.plugins[dhc5bva5].encode()); }
			var dhc5zrdl=this.encodeString(this.additionalJson); this.writeVaruint(dhc5zrdl.length); this.writeBytes(dhc5zrdl);
			return new Uint8Array(this._buffer);
		}

		/** @param {(Uint8Array|Array)} buffer */
		decode(_buffer) {
			this._buffer = Array.from(_buffer);
			var _id=this.readBigEndianByte();
			this.time=this.readVarulong();
			this.max=this.readVaruint();
			var aramynzb=this.readVaruint(); this.acceptedGames=[]; for(var dhc5yncr=0;dhc5yncr<aramynzb;dhc5yncr++){ this.acceptedGames[dhc5yncr]=Types.Game.fromBuffer(this._buffer); this._buffer=this.acceptedGames[dhc5yncr]._buffer; }
			var aramcxzl=this.readVaruint(); this.plugins=[]; for(var dhc5bva5=0;dhc5bva5<aramcxzl;dhc5bva5++){ this.plugins[dhc5bva5]=Types.Plugin.fromBuffer(this._buffer); this._buffer=this.plugins[dhc5bva5]._buffer; }
			this.additionalJson=this.decodeString(this.readBytes(this.readVaruint()));
			return this;
		}

		/** @param {(Uint8Array|Array)} buffer */
		static fromBuffer(buffer) {
			return new Login.NodeInfo().decode(buffer);
		}

		/** @return {string} */
		toString() {
			return "NodeInfo(time: " + this.time + ", max: " + this.max + ", acceptedGames: " + this.acceptedGames + ", plugins: " + this.plugins + ", additionalJson: " + this.additionalJson + ")";
		}

	},

}

//export { Login };